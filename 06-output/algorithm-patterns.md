# コーディング面接で頻出のアルゴリズム大全

## O（オー）記法 ＝ 「どれくらい遅くなるか」の指標

### そもそも何のためにあるん？

**「データが増えたとき、処理時間がどれくらい増えるか」** を表す記号。

正確な数値じゃなくて **「だいたいこのレベル」** っていうランクを表している。

---

### 具体例

配列の要素数を **n** とする。

---

#### O(1) — 「一発で終わる」

```typescript
// 配列の最初の要素を取る
const first = nums[0];
```

n が 10 でも 10,000,000 でも **1回で終わる**。

---

#### O(n) — 「全部1回ずつ見る」

```typescript
// 配列の中から 7 を探す
for (let i = 0; i < nums.length; i++) {
  if (nums[i] === 7) return i;
}
```

| n（データ数） | ループ回数 |
|---|---|
| 10 | 最大 **10回** |
| 1,000 | 最大 **1,000回** |
| 100万 | 最大 **100万回** |

データが **2倍** になったら、時間も **2倍**。素直に比例する。

---

#### O(n²) — 「全員 × 全員を確認する」

```typescript
// 二重ループ（Two Sum のブルートフォース）
for (let i = 0; i < nums.length; i++) {       // n回
  for (let j = i + 1; j < nums.length; j++) {  // 約n回
    if (nums[i] + nums[j] === target) ...
  }
}
```

| n（データ数） | ループ回数 |
|---|---|
| 10 | 約 **100回**（10x10） |
| 1,000 | 約 **1,000,000回**（百万） |
| 10,000 | 約 **100,000,000回**（1億!） |

データが **2倍** になったら、時間は **4倍**！ **10倍** になったら **100倍**！

---

#### O(log n) — 「半分に切っていく」

```typescript
// 二分探索
while (left <= right) {
  const mid = Math.floor((left + right) / 2);
  // 半分を捨てる
}
```

| n（データ数） | ループ回数 |
|---|---|
| 10 | 約 **3回** |
| 1,000 | 約 **10回** |
| 100万 | 約 **20回** |
| 10億 | 約 **30回** |

**10億個あっても30回** で見つかる！

log とは「2を何回かけたらnになるか」という意味。

```
2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 x 2 = 1024
→ log(1024) = 約10回
```

---

### 一覧比較（n = 10,000 のとき）

```
O(1)        →            1回    瞬殺
O(log n)    →           13回    超速い
O(n)        →       10,000回    普通
O(n log n)  →      130,000回    ちょい重い
O(n²)       →  100,000,000回    遅い！
O(2^n)      →      想像不能     爆発
```

グラフイメージ：

```
処理時間
  |
  |                                    / O(n²)
  |                                 /
  |                              /
  |                           /
  |                       /
  |                   /
  |              . ·             -- O(n)
  |         . ·
  |     . ·
  | . ·  - - - - - - - - - - -- O(log n)
  |================================ O(1)
  +-------------------------------> データ数(n)
```

---

### Two Sum で実感

```
ブルートフォース O(n²):
  ループの中にループ → n x n 回

ハッシュマップ O(n):
  ループ1回 + Map.has() は O(1) → n x 1 回
```

**n = 10,000 のとき：**

```
O(n²) → 1億回の計算    → 遅い
O(n)  → 1万回の計算    → 一瞬
```

---

### 覚え方まとめ

| 記法 | 覚え方 | for文の数 |
|---|---|---|
| O(1) | 一発 | ループなし |
| O(log n) | 半分に切る | whileで半減 |
| O(n) | 全部1回見る | for **1つ** |
| O(n log n) | ソートの速さ | `.sort()` |
| O(n²) | 全ペア試す | for **2つ（入れ子）** |

**ざっくり：「forループが何重か」を数えたらだいたいわかる。**

- for 1個 → O(n)
- for 2個（入れ子） → O(n²)
- for 3個（入れ子） → O(n³)

---

---

## 面接で頻出のアルゴリズムパターン

### 1. ハッシュマップ（HashMap / Map）— 出現率No.1

**何ができる？** → 「探し物を一瞬で見つける」

```
× 配列を全部なめて探す → O(n)
○ Map に入れて .has() で聞く → O(1)
```

**代表問題:** Two Sum、Group Anagrams、重複検出

**パターン:**

```
「相方を探す」  → complement = target - 現在値
「グループ分け」→ キーでまとめる
「カウント」    → 出現回数を数える
```

---

### 2. 二分探索（Binary Search）— 「半分に切る」天才

**何ができる？** → 「ソート済みデータを爆速で探す」

```
× 先頭から1個ずつ見る → O(n)
○ 真ん中を見て半分捨てる → O(log n)
```

**代表問題:** Search in Rotated Array、Upper/Lower Bound

**パターン:**

```typescript
while (left <= right) {
  const mid = Math.floor((left + right) / 2);
  if (条件) right = mid - 1;  // 左半分へ
  else      left = mid + 1;   // 右半分へ
}
```

---

### 3. BFS / DFS（幅優先探索 / 深さ優先探索）— グラフ・木の基本

**何ができる？** → 「つながっているものを全部たどる」

| | BFS（幅優先） | DFS（深さ優先） |
|---|---|---|
| データ構造 | **キュー**（Queue） | **スタック**（再帰） |
| 探索順 | 近い順に広がる | 一方向に深く潜る |
| 得意なこと | **最短距離** | **全探索・連結成分** |
| イメージ | 水面に石を落とした波紋 | 迷路を壁にぶつかるまで進む |

**代表問題:** Number of Islands、Shortest Path、ツリー探索

**BFS パターン:**

```typescript
const queue = [スタート];
while (queue.length > 0) {
  const current = queue.shift();
  隣接するノードを queue に追加;
}
```

**DFS パターン:**

```typescript
function dfs(node) {
  if (終了条件) return;
  訪問済みにする;
  隣接するノードに対して dfs(隣);
}
```

---

### 4. ソート + 貪欲法（Greedy）— 「並べてから欲張る」

**何ができる？** → 「最適な順番で処理する」

```
1. まずソートする
2. 先頭 or 末尾から貪欲に選ぶ
```

**代表問題:** Merge Intervals、Task Scheduler、Meeting Rooms

**パターン:**

```typescript
items.sort((a, b) => a.start - b.start);  // まず並べる
for (const item of items) {
  if (前のやつと重なる) マージ;
  else 新しく追加;
}
```

---

### 5. スライディングウィンドウ — 「窓をずらす」

**何ができる？** → 「連続する範囲の最適解を効率よく求める」

```
× 全部の部分配列を試す → O(n²)
○ 窓を右にずらしながら計算 → O(n)
```

**代表問題:** 最長部分文字列、Rate Limiter、移動平均

**パターン:**

```typescript
let left = 0;
for (let right = 0; right < n; right++) {
  窓に right を追加;
  while (条件を満たさない) {
    窓から left を除外;
    left++;
  }
  答えを更新;
}
```

---

### 6. 動的計画法（DP）— 「メモしながら積み上げる」

**何ができる？** → 「重複する計算を一度だけにする」

```
× 同じ計算を何度もやる（再帰） → 指数的
○ 結果をメモして再利用 → O(n) や O(n²)
```

**代表問題:** フィボナッチ、ナップサック、最長共通部分列

**パターン:**

```typescript
dp[i] = dp[i-1] に何かを足す or 比較
```

---

### 7. ヒープ / 優先度キュー — 「常にベストを取り出す」

**何ができる？** → 「最大 or 最小をO(log n)で取得」

**代表問題:** Top K Frequent、Priority Task Queue、K Closest Points

**パターン:**

```
常に最小（or最大）が先頭にいるデータ構造
→ 追加 O(log n)、取り出し O(log n)
```

---

## 面接での出現頻度ランキング

```
1位 HashMap              ほぼ毎回出る
2位 BFS/DFS              グラフ・木の問題は定番
3位 二分探索              「ソート済み」が出たら即これ
4位 ソート+Greedy         区間・スケジュール系
5位 スライディングウィンドウ 文字列・配列の連続部分
6位 DP                   中〜上級で頻出
7位 ヒープ               Top K系で出る
```

---

## 「この問題はどのアルゴリズム？」の見分け方

| 問題のキーワード | 使うアルゴリズム |
|---|---|
| 「2つの合計」「ペアを探せ」 | **HashMap** |
| 「ソート済み配列で探す」 | **二分探索** |
| 「最短距離」「最短経路」 | **BFS** |
| 「島の数」「連結成分」 | **DFS / BFS** |
| 「区間をマージ」「スケジュール」 | **ソート + Greedy** |
| 「連続する部分配列」「ウィンドウ」 | **スライディングウィンドウ** |
| 「Top K」「K番目に大きい」 | **ヒープ** |
| 「最小コスト」「場合の数」 | **DP** |
| 「全パターン試す」（n <= 10〜15） | **ビットマスクDP / バックトラック** |

---

## このプロジェクトの問題とパターンの対応

| パターン | 問題 |
|---|---|
| **HashMap** | Two Sum, Group Anagrams |
| **二分探索** | Search Rotated Array |
| **BFS/DFS** | Number of Islands, Shortest Path |
| **ソート+Greedy** | Merge Intervals, Task Scheduler |
| **ヒープ** | Priority Task Queue, Top K Frequent |
| **クイックセレクト** | K Closest Points |
| **ビットマスクDP** | Delivery Route Optimizer |
| **スライディングウィンドウ** | Rate Limiter |
