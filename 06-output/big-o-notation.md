# O記法（計算量）完全ガイド

## O記法とは？

**「データが増えたとき、処理時間がどれくらい増えるか」** を表す記号。

正確な実行時間ではなく、 **「データが増えたときの増え方のパターン」** を表す。

---

## 各O記法の解説

### O(1) — 定数時間「一発で終わる」

```typescript
// 配列の最初の要素を取る
const first = nums[0];

// Map から値を取る
const value = map.get("key");
```

n が 10 でも 10,000,000 でも **1回で終わる**。

**該当する操作:**
- 配列のインデックスアクセス `arr[i]`
- Map の `get()`, `set()`, `has()`
- 変数の代入、四則演算

---

### O(log n) — 対数時間「半分に切っていく」

```typescript
// 二分探索
while (left <= right) {
  const mid = Math.floor((left + right) / 2);
  if (nums[mid] === target) return mid;
  if (nums[mid] < target) left = mid + 1;
  else right = mid - 1;
}
```

| n（データ数） | ループ回数 |
|---|---|
| 10 | 約 3回 |
| 100 | 約 7回 |
| 1,000 | 約 10回 |
| 100万 | 約 20回 |
| 10億 | 約 30回 |

**log とは？**

「2を何回かけたら n になるか」

```
2^1  = 2
2^2  = 4
2^3  = 8
2^10 = 1,024      → log(1,024) = 10
2^20 = 1,048,576   → log(100万) = 約20
2^30 = 1,073,741,824 → log(10億) = 約30
```

**該当するアルゴリズム:**
- 二分探索
- バランス二分木の操作
- ヒープの挿入・削除

---

### O(n) — 線形時間「全部1回ずつ見る」

```typescript
// 配列の合計を求める
let sum = 0;
for (let i = 0; i < nums.length; i++) {
  sum += nums[i];
}
```

| n（データ数） | ループ回数 |
|---|---|
| 10 | 10回 |
| 1,000 | 1,000回 |
| 100万 | 100万回 |

データが **2倍** → 時間も **2倍**（比例する）

**該当するアルゴリズム:**
- HashMap を使った Two Sum
- 配列の線形探索
- カウント処理

---

### O(n log n) — 「ソートの速さ」

```typescript
// JavaScriptのsort
nums.sort((a, b) => a - b);
```

| n（データ数） | 計算回数 |
|---|---|
| 10 | 約 33回 |
| 1,000 | 約 10,000回 |
| 100万 | 約 2,000万回 |

**該当するアルゴリズム:**
- マージソート
- クイックソート（平均）
- ヒープソート
- `Array.sort()`

---

### O(n²) — 二乗時間「全ペアを試す」

```typescript
// 二重ループ
for (let i = 0; i < nums.length; i++) {       // n回
  for (let j = i + 1; j < nums.length; j++) {  // 約n回
    // ここが n x n 回実行される
  }
}
```

| n（データ数） | ループ回数 |
|---|---|
| 10 | 約 100回 |
| 100 | 約 10,000回 |
| 1,000 | 約 1,000,000回（百万） |
| 10,000 | 約 100,000,000回（1億!） |

データが **2倍** → 時間は **4倍**
データが **10倍** → 時間は **100倍**

**該当するアルゴリズム:**
- ブルートフォースの Two Sum
- バブルソート
- 挿入ソート
- 単純な区間処理

---

### O(2^n) — 指数時間「全パターン列挙」

```typescript
// フィボナッチ（メモ化なし）
function fib(n: number): number {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2); // 2回再帰 → 指数的に増える
}
```

| n | 計算回数 |
|---|---|
| 10 | 約 1,000回 |
| 20 | 約 100万回 |
| 30 | 約 10億回 |
| 40 | 約 1兆回（実質不可能） |

**該当するアルゴリズム:**
- 部分集合の全列挙
- メモ化なしの再帰

---

## 一覧比較表

### n = 10,000 のとき

| 記法 | 計算回数 | 評価 |
|---|---|---|
| O(1) | 1回 | 瞬殺 |
| O(log n) | 13回 | 超速い |
| O(n) | 10,000回 | 普通 |
| O(n log n) | 130,000回 | ちょい重い |
| O(n²) | 100,000,000回 | 遅い |
| O(2^n) | 想像不能 | 爆発 |

### グラフイメージ

```
処理時間
  |
  |                                    / O(n²)
  |                                 /
  |                              /
  |                           /
  |                       /
  |                   /
  |              . ·             -- O(n)
  |         . ·
  |     . ·
  | . ·  - - - - - - - - - - -- O(log n)
  |================================ O(1)
  +-------------------------------> データ数(n)
```

---

## 簡単な見分け方

### for ループの数を数える

| コードの構造 | 計算量 |
|---|---|
| ループなし | O(1) |
| while で毎回半分にする | O(log n) |
| for 1個 | O(n) |
| `.sort()` | O(n log n) |
| for 2個（入れ子） | O(n²) |
| for 3個（入れ子） | O(n³) |

### 例

```typescript
// O(1) — ループなし
return nums[0] + nums[1];

// O(n) — for 1個
for (let i = 0; i < n; i++) { ... }

// O(n²) — for 2個（入れ子）
for (let i = 0; i < n; i++) {
  for (let j = 0; j < n; j++) { ... }
}

// O(n log n) — sort
nums.sort((a, b) => a - b);

// O(log n) — 毎回半分
while (left <= right) {
  mid = (left + right) / 2;
  ...半分に絞る...
}
```

---

## 面接での制約から計算量を推測する

面接で制約（constraints）を見たら、求められている計算量がわかる：

| 制約（nの範囲） | 期待される計算量 | 使えるアルゴリズム |
|---|---|---|
| n <= 10 | O(n!) や O(2^n) OK | 全探索、バックトラック |
| n <= 20 | O(2^n) ギリギリ | ビットマスクDP |
| n <= 100 | O(n³) OK | 三重ループ |
| n <= 1,000 | O(n²) OK | 二重ループ |
| n <= 10,000 | O(n²) ギリギリ | 二重ループ（注意） |
| n <= 100,000 | O(n log n) 必要 | ソート、ヒープ |
| n <= 1,000,000 | O(n) 必要 | HashMap、線形探索 |
| n <= 10億 | O(log n) 必要 | 二分探索 |

**ポイント:** 1秒間に処理できるのはだいたい **1億回** が目安。

```
n = 10,000 で O(n²) → 1億回 → ギリギリ1秒
n = 100,000 で O(n²) → 100億回 → タイムアウト！
→ O(n log n) 以下の解法が必要
```

---

## 空間計算量（メモリ）

時間だけじゃなく、メモリの使用量も O 記法で表す：

| 使い方 | 空間計算量 |
|---|---|
| 変数を数個使うだけ | O(1) |
| n個の要素をMapに入れる | O(n) |
| n x n の二次元配列を作る | O(n²) |

### 例: Two Sum

```typescript
// ブルートフォース: 追加のメモリなし → 空間 O(1)
for (let i ...) for (let j ...) ...

// HashMap: 最大n個をMapに入れる → 空間 O(n)
const map = new Map(); // 最大n個のエントリ
```

**トレードオフ:** HashMap解法は時間 O(n) だが空間 O(n)。
ブルートフォースは時間 O(n²) だが空間 O(1)。
→ 面接では通常「時間を優先」するので HashMap が好まれる。

---

## このプロジェクトの問題の計算量まとめ

| 問題 | ブルートフォース | 最適解 |
|---|---|---|
| Two Sum | O(n²) | O(n) HashMap |
| Group Anagrams | O(n * k log k) | O(n * k) カウント |
| Merge Intervals | - | O(n log n) ソート |
| Search Rotated Array | O(n) | O(log n) 二分探索 |
| Task Scheduler | - | O(n) カウント+公式 |
| Top K Frequent | O(n log n) ソート | O(n) バケットソート |
| Number of Islands | - | O(m * n) BFS/DFS |
| Shortest Path Grid | - | O(m * n) BFS |
| K Closest Points | O(n log n) ソート | O(n) クイックセレクト |
| Delivery Route Optimizer | O(n! * n) 全探索 | O(2^n * n²) ビットマスクDP |
| Priority Task Queue | O(n log n) 毎回ソート | O(log n) ヒープ |
| Rate Limiter | O(n) filter毎回 | O(1) 償却 ポインタ |
